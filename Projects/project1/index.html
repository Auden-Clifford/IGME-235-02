<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="UTF-8">
        <meta name="viewport" content="width=device-width, initial-scale=1.0">
        <title>Auden Clifford - Personal Portfolio</title>
        <link rel="stylesheet" href="CSS/mainStyles.css">
    </head>
    <body>
        <header>
            <nav id="topNav">
                <ul>
                    <li><a href="#spinner">Spinner Scorge</a></li>
                    <li><a href="#sgb">Shotgun Boomerang</a></li>
                    <li><a href="#basement">Basement Green</a></li>
                </ul>
            </nav>

            <div id="headerGrid">
                <div id="banner"><img src="media/banner_short.png" alt=""></div>

                <div id="title">
                    <h1>Auden William Paul Clifford <hr> Personal Portfolio</h1>
                </div>

                <div id="headline" class="multiContainter">
                    <img src="media/profile.jpg" alt="" id="profile">
                    <p>
                        RIT student | Pursuing a computing degree in Game Design and Development | Computer Programmer | Interested in VR
                </div>
            </div>
        </header>

        <main>
            <nav id="thumbnailGrid">

                <div id="aboutMe" class="info">
                    <h2>About Me</h2>
                    <p>
                        I’m Auden Clifford, A second-year Game Design and Development student at Rochester Institute of Technology. I first developed a taste for designing games during 
                        highschool when I got into Minecraft modding and writing Dungeons & Dragons campaigns. In the present day, I'm learning the big stuff in class and exploring VR 
                        development in my own time. I excel at the programming side of things and always enjoy a challenge or an interesting logic problem. I'm well-versed in various 
                        tools like Visual Studio, IntelliJ, Unity, Unreal, MonoGame, Source 2, Photoshop, Maya, Blender, and GitHub.The coding languages I've worked with so far include C#, 
                        JavaScript, Java, Python, HTML, and CSS.
                    </p>
                </div>

                <div id="sgbImage" class="thumbnail">
                    <a href="#sgb"><img src="media/SGB_Cave.PNG" alt="Bookmark link to Shotgun Boomerang"></a>
                </div>

                <div id="sgbTitle" class="thumbnailTitle">
                    <a href="#sgb">SHOTGUNBOOMERANG</a>
                </div>

                <div id="sgbType" class="projectType">
                    Acedemic Project
                </div>

                <Div id="sgbLang" class="codingLanguage imageContainer">
                    <img src="media/Csharp-mark.png" alt="developed in C#">
                </Div>

                <div id="sgbRepo" class="repoLink imageContainer">
                    <a href="https://github.com/Auden-Clifford/SHOTGUN-BOOMERANG">  
                        <img src="media/github-mark-white.png" alt="GitHub Link">
                    </a>
                </div>


                <div id="bgImage" class="thumbnail">
                    <a href="#basement"><img src="media/basement_green_top.PNG" alt="Bookmark link to Basement Green"></a>
                </div>

                <div id="bgTitle" class="thumbnailTitle">
                    <a href="#basement">Basement_Green</a>
                </div>

                <div id="bgType" class="projectType">
                    Personal Project
                </div>

                <!--repo not yet set up-->
                <div id="bgRepo" class="repoLink imageContainer">
                    <a href="https://github.com/404"> 
                        <img src="media/github-mark-white.png" alt="GitHub Link">
                    </a>
                </div>

                <div id="spImage" class="thumbnail">
                    <a href="#spinner"><img src="media/SC_gameplay.PNG" alt="Bookmark link to Spinner Scorge"></a>
                </div>

                <div id="spTitle" class="thumbnailTitle">
                    <a href="#spinner">Spinner Scorge</a>
                </div>

                <div id="spType" class="projectType">
                    Acedemic Project
                </div>

                <div id="spLang" class="codingLanguage imageContainer">
                    <img src="media/Csharp-mark.png" alt="developed in C#">
                </div>

                <div id="spEngine" class="codingLanguage imageContainer">
                    <img src="media/unityLogo-white.png" alt="developed in Unity Engine">
                </div>

                <div id="spRepo" class="repoLink imageContainer">
                    <a href="https://github.com/IGME-202-2231/project-1-Auden-Clifford">  
                        <img src="media/github-mark-white.png" alt="GitHub Link">
                    </a>
                </div>
            </nav>

            <section id="spinner">
                <h2>Spinner Scorge</h2>
                <nav>
                    <a href="https://github.com/IGME-202-2231/project-1-Auden-Clifford">GitHub</a><br>
                    <a href="https://igme-202-2231.github.io/project-1-Auden-Clifford/">Play</a>
                </nav>

                <p>
                    I was tasked with creating my own version of a classic top-down shoot 'em-up game in Unity. The game I created was Spinner Scorge, the base concept for which was 
                    “What if we give Beyblades guns?” So I set out to introduce the chaotic interactions of clashing spinners to the SHMUP genre.
                </p>

                

                <h3>Game Mechanics</h3>

                <p>
                    Just like dueling with Beybldes, stop spinning and you’re out. Angular velocity is key–it’s your health. Collisions chip away at it, and spinners with guns can shoot to 
                    slow rivals down. Replenishing your spinner's speed requires defeating enemies or surviving waves.
                </p>

                <p>
                    The goal of the game is simple: rack up the highest score possible. When your spinner stops spinning, it's game over, but every new attempt is a chance to outdo yourself. 
                    Your score climbs with each enemy downed, and tougher foes offer bigger bounties. Enemies will appear randomly each round, escalating in number and challenge per round. 
                    Completing a round means clearing all enemies, immediately triggering the next round, and spawning new enemies.
                </p>

                <p>
                    I pushed this game beyond traditional SHMUP constraints by implementing a physics system for authentic top-like spinner interactions. Without relying on Unity’s default rigid 
                    body collision system, I created my own custom-coded forces and collision detection to allow spinners to push and crash into each other.
                </p>

                <figure id="spCollide" class="multiContainter">
                    <img src="media/spinner.gif" alt="">

                    <p>
                        Wham! The spinners collide and are sent flying across the map. This chaotic motion was achieved using my own custom script. 
                    </p>
                </figure>

                <p>
                    Commonly, in a SHMUP the player shoots enemies inside a fixed area or perpetually scrolls in one direction. However, in order to evoke the chaotic energy of a Beyblade duel 
                    my game allows limitless movement across an endless map; the player can go anywhere and the enemies can come from any direction. From there, the game follows the player, 
                    moving the background and spawning enemies nearby.
                </p>

                <h4>Enemy Types</h4>
                <ul>
                        <li id="spEnemyStandard" class="multiContainter">
                            <img src="media/Spinner_EnemyStandard.svg" alt="">
    
                            <p>
                                <strong>Standard Enemy</strong> - These enemies seek out the player and attempt to collide with them. They're small and a little slower than the player, 
                                however they are the most plentiful of the enemies and can easily overwhelm the player.
                            </p>
                        </li>


                        <li id="spEnemyShoot" class="multiContainter">
                            <img src="media/Enemy_Shooter.svg" alt="">
    
                            <p>
                                <strong>Shooter Enemy</strong> - Instead of being a melee threat, when these enemies get close to the player they shoot a fan of bullets out in a circle, 
                                causing chaos for friend and foe alike. These enemies are somewhat rare, only one will spawn for every 5 standard enemies.
                            </p>
                        </li>


                        <li id="spEnemyFast" class="multiContainter">
                            <img src="media/Enemy_Fast.svg" alt="">
    
                            <p>
                                <strong>Fast Enemy</strong> - These enemies are fast, small, and pack a massive punch, the fast enemies are capable of shredding a player's health bar very 
                                quickly. These enemies are rare, only 1 will spawn for every 10 standard enemies spawned.
                            </p>
                        </li>

                </ul>

                <h3>Problems Overcome</h3>

                <p>
                    When I started this project I was still in the process of getting acquainted with Unity’s component-based architecture. Re-adjusting my thinking to work with this 
                    system was challenging and led to some code issues earlier in the project. Some of my components were heavily coupled with others and would not function if the 
                    other components were not present. I managed to cut back on these design issues later in the project, designing my components to be more self-sufficient and 
                    function on their own. There are still some components that rely on others in order to work, but in the end, I made sure not to code this way unless I was sure it 
                    was necessary for the function of the program.
                </p>

                <p>
                    I also had some trouble implementing the physics system for this game. I realized that calculating the forces involved in the collision of two objects would not 
                    be as simple as rearranging some College Physics I equations so I ended up reaching out to a friend for help. This friend, an upperclassman and a physics major, 
                    informed me that the answer I wanted would require that the computer perform a computationally expensive operation each time collisions were detected and that 
                    rather than spending time figuring this problem out only for it to cause massive lag, I should just fudge the collision as accurately as possible and leave it at 
                    that. This was an imperfect solution, but it highlighted an important lesson I learned during this project which is that I don’t always need a perfect solution. 
                    The collision system I ended up with works well enough despite not being completely accurate to real-life conservation of momentum and honestly might feel better 
                    during gameplay than if the system was completely physically accurate. 
                </p>

                <h3>What I Would do Differently</h3>

                <p>
                    I’m pretty happy with how this project turned out all things considered. It’s still fairly 
                    recent so I’ve yet to have any huge revelations that make me rethink my approach to the code. 
                    The only thing I think I might change given the time is I would spend some more time looking at 
                    existing rigid body collision algorithms to see how mine might be improved upon.
                </p>

                <p>
                    As for features I’d like to add, I would want to add bits of terrain and walls around the map 
                    to give the arena more interest than it currently has. Right now my script only handles 
                    bounding circle collisions so adding any kind of walls or terrain would have required me to 
                    make major changes to the collision system. My hope is that having terrain to bounce off of 
                    in addition to enemies would keep the fights more interesting and would be more evocative of a 
                    Beyblade duel where the spinners are as likely to bounce off the sides of the arena as each 
                    other.
                </p>
            </section>

            <section id="sgb">
                <h2>SHOTGUNBOOMERANG</h2>
                <nav>
                    <a href="https://github.com/Auden-Clifford/SHOTGUN-BOOMERANG">GitHub</a><br>
                </nav>

                <p>
                    For this project I worked with a team to create a side-scrolling 
                    physics-based run-and-gun platformer in MonoGame. Over the course of the project I 
                    was able to flex my programming and debugging skills and learned firsthand 
                    the importance of team coordination and communication.
                </p>

                <aside id="sgbLore" class="multiContainter">
                    <p> 
                        In SHOTGUNBOOMERANG, you play as "John Boomerang" a retired merc living in the 
                        Australian outback who's forced back into action when his old organization, known 
                        only as "The Company", comes after him.
                    </p>

                    <p>
                        As you traverse the levels you are set upon by mutant outback wildlife controlled and 
                        released by The Company. With only your trusty shotgun and boomerang at your side, 
                        can you make it back to civilization to confront your old employers?
                    </p>

                    <img src="media/SGB_outback.PNG" alt="">
                </aside>

                <h3>My Contributions</h3>

                <ul>
                    <li>Debug Mode</li>
                    <li>Level Editor</li>
                    <li>Physics Collisions</li>
                    <li>Player Systems</li>
                </ul>

                <p>
                    My primary role in the project was to be in charge of the physics system. 
                    Physics interaction between game objects was a large focus of the 
                    gameplay. Thus, the system I created had to be robust if the project was 
                    to succeed. The system I developed utilized an axis-aligned bounding box 
                    system to detect collisions between objects in the game. These objects 
                    would then decide internally how to resolve the collision.
                </p>

                <p>
                    During the development of the physics system, I worked on the player 
                    class in tandem and often used the player as a test for new physics 
                    code. The player class reads user inputs and tracks the player’s state 
                    through an internal finite state machine. I would make significant 
                    changes to this part of the project quite a few times during development 
                    as the team iterated on our plan for what states were necessary for the 
                    player to track and what each of them meant for the player’s interaction.
                </p>

                <figure id="sgbDebug" class="multiContainter">
                    <img src="media/SGB_debug.PNG" alt="">

                    <p>
                        <strong>Debug Mode</strong> in action; Hitboxes are highlited, the shotgun's effective radius is drawn, along with it's curent spread, and In the top-left corner various useful statistics are displayed.
                    </p>
                </figure>

                <p>
                    I created a debug mode to mitigate the effects of the project’s 
                    increasing complexity on our ability to find and correct errors. This 
                    system would allow us to visually track key information like hitboxes and 
                    weapon attack areas as well as certain physics properties like the 
                    position and velocity of significant game objects.
                </p>

                <p>
                    My second largest role in the project was the development of an external 
                    tool for level editing that interfaced with the game via a file I/O 
                    system. I created a UI system using Windows Forms that allowed the user 
                    to “paint” game tiles onto a canvas to create level files. Additionally, 
                    I created the class in our main MonoGame project that could read these 
                    files and turn them into playable levels.
                </p>

                <h3>Problems Overcome</h3>

                <ul>
                    <li>Physics problem</li>
                    <li>Lag: Level Editor</li>
                    <li>Planning Problem</li>
                </ul>

                <p>
                    One of the largest setbacks during this project came when we encountered a physics bug. Keeping 
                    momentum and flow with physics-based movement was essential to the gameplay loop, so the bug was 
                    potentially catastrophic if it wasn’t fixed. I set up several troubleshooting meetings with the 
                    team so that we could all discuss potential solutions. Our initial approaches only seemed to swap 
                    the location where the bug was occurring, it was only when I looked at the problem from a 
                    different angle that I was able to come up with the answer. All of our solutions up to then had 
                    been focused on the order in which collisions were resolved on the horizontal or vertical axis. 
                    However, I realized that rather than resolving one axis or the other first, resolving the 
                    collisions in order of largest area would always result in a more optimal outcome. We had been 
                    stuck in a loop of thinking of solutions centered on one axis or the other and it took me 
                    stepping back and looking at the problem as a whole to realize a solution.
                </p>

                <figure id="sgbEditor" class="multiContainter">
                    <img src="media/editor.gif" alt="">

                    <p>
                        In the current build, scrolling around the level is quick and easy. This was not always the case, before I fixed the issue moving from one part of the level to the other could take several seconds.
                    </p>
                </figure>

                <p>
                    Sometimes a bug causes catastrophic consequences for a project, and sometimes they’re just 
                    annoying. This was the case with a different issue I encountered while working on the level 
                    editor. I had the program in a state where it technically worked, however, if the user attempted 
                    to scroll the view from one area of the level to another it would take several seconds for the 
                    view to respond. It was working, just really slowly. The editor used a 2D array of picture boxes 
                    to display game tiles in the 2D environment where each tile in a level would be represented by a 
                    picture box. The problem was that picture boxes are somewhat complex structures, and each time 
                    the user scrolled around the level, these boxes would need to be moved around or hidden as they 
                    moved offscreen. This process caused significant lag, and the problem would become much worse 
                    with larger levels. I was eventually able to come up with a solution for this issue by rethinking 
                    the way tiles were stored in the program. Rather than each tile being assigned its own picture 
                    box, only the tiles’ sprites would be stored in the 2D array. The sprites would then fill into a 
                    smaller grid of picture boxes making up the viewport as they came into view. This way, the 
                    program only needed enough picture boxes to fill the view and didn’t have to deal with the 
                    computationally expensive process of moving and hiding the boxes, now only needing to swap out 
                    their image when the user scrolls.
                </p>

                <p>
                    Aside from just coding errors, we also had to tackle some structural issues as well. 
                    Specifically, we encountered an issue that was caused by a lack of a realistic plan for the 
                    overall gameplay loop. We had core mechanics we knew we were going to implement, but some of our 
                    plans were very loosely defined and often overambitious. Aspects we originally thought of for 
                    the gameplay loop included traversal challenges, clearing enemies, puzzle solving, boss 
                    monsters, and even cutscenes! As the project went on, however, it became clear that many of 
                    these things would have to become stretch goals. Additionally, it should have been clear to us 
                    from the beginning that the gameplay would not feel like a focused and coherent experience with 
                    so many different modes of play. Luckily, as we got further into the project our team was able 
                    to recognize that our plan needed to be re-focused and we would meet several times to discuss 
                    restructuring parts of the project.
                </p>

                <h3>What I Would Change</h3>

                <p>
                    If I were to do this project again the first thing I would change would be to spend more time on planning. It definitely became clear to us over the course of the 
                    project that having clear and realistic goals streamlines production. If we had spent less time rolling back and forth between ideas and more time implementing 
                    systems that we planned weeks in advance we could have finished the project much more quickly and incorporated many more stretch goals. 
                </p>

                <p>
                    In hindsight, I believe that many of my solutions for passing information between classes were less than ideal. Being more experienced now in the ways of 
                    reducing coupling and managing information There are a few systems that I may replace or alter to streamline their functioning. One thing that I may change is 
                    the collision detection system. Each object in the game currently runs its own collision detection function internally by checking its own bounds against those 
                    of each other object in the level. This, of course, requires that each game object has access to a list of all other objects. Rather than do this I would remake 
                    this system to include some sort of collision manager class, likely a singleton, that checks for any collisions each frame and then allows the objects to resolve 
                    their collisions internally. Additionally, unlike the current system, which has a different collision detection process for different types of objects, this 
                    system would not care whether the object was an enemy, a tile, or a projectile; it would be able to simply detect these collisions and tell the objects to resolve 
                    them regardless of what kind of objects they are.
                </p>

            </section>

            <section id="basement">
                <h2>Basement_Green</h2>

                <p>
                    In this project I created an immersive VR environment based on a real photo as a method to practice my level and environment design skills. 
                </p>

                <h3>Goals</h3>
                <ul>
                    <li>Test my VR design skills</li>
                    <li>Learn about the Source 2 engine</li>
                    <li>Create an immersive VR environment</li>
                </ul>
                
                <p>
                    Leading up to this project I had been following a series of online tutorials to learn the use of the the Valve developer tools that come with the VR game 
                    Half-Life: Alyx. I had spent a lot of time completing assorted exercises to practice the different tools and techniques of VR development, but had yet to use 
                    them in a complete project.
                </p>

                <p>
                    I wanted to test what I had learned so far and cement my understanding of the development tools I had been given so I decided to start a mapping project. The goal 
                    was to create a fully-detailed level within Half-Life: Alyx’s Hammer Editor. I wanted this environment to be as immersive as possible to truly take advantage of 
                    the VR platform’s strengths.
                </p>

                <p>
                    Beyond simply practicing the skills I had learned, however, I hoped the project would push me to learn more about the editor as I tackled unforeseen problems and 
                    thought of new things to try. I have found that “learning by doing” is one of the fastest ways to pick up skills you otherwise would have never encountered.
                </p>

                <h3>The Challenge</h3>

                <figure id="bgReference" class="multiContainter">
                    <img src="media/abandoned_basement_green.jpg" alt="">
                    <img src="media/basement_green_1.PNG" alt="">

                    <p>
                        On top is the original image I referenced for the project and below is the closest equivalent viewpoint from the VR environment. The overall structure of the building is the same, but the lighting in the VR scene is much more dramatic.
                    </p>
                </figure>

                <p>
                    I decided to come up with a relatively simple challenge for myself to serve as a springboard for the project. The goal would be to choose an image from somewhere 
                    on the internet and recreate it as faithfully as possible in a VR environment. Furthermore, I would need to extrapolate from the image and create some areas of 
                    the environment that are not visible in the original.
                </p>

                <p>
                    The image I chose was a fairly simple photo of a rubbled abandoned basement. It was a small enough space that I could reasonably expect to recreate it faithfully 
                    but also had enough interest and detail to allow me to push my skills. Additionally, the image clearly implied that there were other areas connected to the 
                    basement that were not in view, such as a stairwell and an upstairs.
                </p>
                
                <p>
                    I began by boxing out a rough outline of the environment before moving on to add details. I decided that the environment would be split into 3 areas: the 
                    basement, which is visible in the image; the stairwell, the entrance to which is visible in the image but which is otherwise unseen; and the upstairs, which can 
                    just barely be seen in the image through the holes in the basement’s ceiling.
                </p>

                <p>
                    The contents and design of the basement were more or less already decided for me by the image. However, I would have to come up with my own plan for the 
                    stairwell and upper floor. I wanted the upper floor to contrast the basement, so I decided that it would be a cleaner, well-lit environment with several windows 
                    and a skylight to juxtapose the basement’s cluttered, chaotic darkness. 
                </p>

                <figure id="bgOther" class="multiContainter">
                    <img src="media/basement_green_2.PNG" alt="">
                    <img src="media/basement_green_4.PNG" alt="">

                    <p>
                        Neither the stairwell (top) nor the upstairs (bottom) are visible in the original image, so the designs had to be thought up on the fly. I think these do a good job of encapsulating the range of different environments that can be created in Half-Life: Alyx.
                    </p>
                </figure>
                
                <p>
                    The stairwell was a bit different, since it would be hidden from the view of both the 
                    basement and the upstairs I could basically do whatever I wanted with it. I decided to use this place to practice working with more organic environments since 
                    the other two areas did not present much opportunity to do so. To spice things up a bit I decided to fill the area with some of Half-Life: Alyx’s alien flora 
                    assets, creating a truly bizarre spectacle things that glow and things that grow.
                </p>

                <p>
                    Once these interiors were done, there was one last piece that I wanted to add. The upstairs windows looked out on an endless void, and I had yet to practice my 
                    skills at using Hammer editor’s 3D skybox system. Naturally, this was the perfect opportunity to add some background elements to ground the scene in a more 
                    immersive reality. Creating a skybox pushed me to learn about Source 2’s prefab architecture and forced me to figure out how to use tools to control the scene’s 
                    lighting.
                </p>

                <p>
                    I also ran into a common VR design challenge in the course of the project. It’s pretty well known that one of the main drawbacks of VR devices is the potential to 
                    cause motion sickness. This is especially the case when the player must navigate uneven terrain which causes the view to move up and down rapidly. This is exactly 
                    the problem the uneven, rubble-covered floor of the basement caused. I wanted to make this environment as VR-friendly as possible, so I couldn’t just leave it as 
                    it was, however, I also didn’t want to make the basement floor completely flat since it would feel unnatural compared to the dilapidated state of the rest of the 
                    room and break immersion. Instead, I created a fake invisible floor to go overtop the bumpy terrain. The player could now walk around the floor without causing 
                    motion sickness and no aesthetic value was lost.
                </p>

                <p>
                    I was very happy with the end result. The map I made was no sprawling spectacle of awe, but that small space was packed with detail and I tend to think that VR 
                    gameplay shines in compact environments.
                </p>

                <h3>What I Would Change</h3>

                <p>
                    Much of this project was simply done on the fly. I implemented ideas in as they came to me and didn’t do too much planning before the project began. Since my goal 
                    was to learn as much as possible about Source 2 and VR development, this approach was beneficial as it allowed me to naturally explore new concepts. If I were to 
                    start a similar project with any purpose other than learning I would spend much more time in planning. I would want to sketch floor plans for the levels and come 
                    up with methods to emphasize important game mechanics.
                </p>
            </section>



            

        </main>
        <footer>
            <section>
                <h2>Contact</h2>
            <address>
                <ul>
                    <li><a href="www.linkedin.com/in/auden-clifford">LinkedIn</a></li>
                    <li><a href="mailto:awpclifford@gmail.com">email</a></li>
                    <li>Phone: (838) 202-7433</li>
                </ul>
            </address>
            </section>
            
            <section>
                <h2>Documentation</h2>
            <a href="doc.html">Site design documentation</a>
            </section>
        </footer>
    </body>
</html>